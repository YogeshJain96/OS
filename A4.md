1. Create 5 children processes from a common parent and ensure that the
parent terminates after cleaning all the terminated children using waitpid().
The waitpid() must be called after all the children are created
and the parent has completed its work real work,if any. You must interpret
the exit code of the cleaned-up processes, using waitpid(), in parent process
– you must cover all the possible scenarios !!!
```
#include<stdio.h>
#include<unistd.h>
#include <sys/types.h>
#include <sys/wait.h>
int main()
{
	pid_t pid;

	for(int i=0;i<5;i++)
	{
	pid=fork();
	if(pid<0)
	{
		printf("Fork failed");
	}
	if(pid==0)
	{
		sleep(30);
		printf("\nIn Child Process\n");
		printf("\nChild Process ID: %d\n",getpid());
		printf("\nParent Process ID: %d\n",getppid());
		break;
	}
	else
	{
		printf("\nIn Parent Process\n");
		printf("\nChild Process ID: %d\n",pid);
		printf("\nParent Process ID: %d\n",getpid());
		int status=0;
		waitpid(pid,&status,0);
		if(WIFEXITED(status))
		{
			printf("\nExited Normally\n");
		}
	}
	}
}

```

2. Create 5 processes but not from the common parent. Meaning, each child
creates a new process. clean-up the children using waitpid(). waitpid()
must be called after all the children are created and the parent has
completed its work real work,if any. You must interpret the exit code of the
cleaned-up processes, using waitpid(), in the parent process
– you must cover all the possible scenarios !!!
```
#include<stdio.h>
#include<unistd.h>
#include <sys/types.h>
#include <sys/wait.h>
int main()
{
        pid_t pid,cid;

        for(int i=0;i<5;i++)
        {
        pid=fork();
	
        if(pid<0)
        {
                printf("Fork failed");
        }
        if(pid==0)
        {
                printf("\nIn Child Process\n");
                printf("\nChild Process ID: %d\n",getpid());
                printf("\nParent Process ID: %d\n",getppid());
		cid=fork();
		if(cid<0)
		{
			printf("\nFork is failed");
		}
		if(cid==0)
		{
			printf("\nChild of Child \n");
			printf("\nChild of child process ID:%d\n",getpid());
			printf("\nParent of Child process ID:%d\n",getppid());
		}
		else
		{
			printf("\nParent of Child\n");
			printf("\nParent of Child process:%d",getpid());
			printf("\nChild of Child process:%d",cid);
			int stat=0;
			waitpid(cid,&stat,0);
		}
		break;
        }
        else
        {
                printf("\nIn Parent Process\n");
                printf("\nChild Process ID: %d\n",pid);
                printf("\nParent Process ID: %d\n",getpid());
                int status=0;
                waitpid(pid,&status,0);
                if(WIFEXITED(status))
                {
                        printf("\nExited Normally\n");
                }
        }

	}
}

```

3. Create a 5 child process from a common parent and launch different
applications from the children processes - you may launch firefox
Gedit, and gcc - parent process must use waitpid() to
collect the termination status of the child process - waitpid()
must be called after all the children are created and the parent has
completed its work real work,if any. You must interpret the exit code of the
cleaned-up processes, using waitpid(), in the parent process
– you must cover all the possible scenarios -
meaning, terminate the children processes normally(successful/
unsuccessful) or abnormally !!!
```
#include<stdio.h>
#include<unistd.h>
#include <sys/types.h>
#include <sys/wait.h>
int main()
{
	pid_t pid;
	int i;

	for(i=0;i<5;i++)
	{
	pid=fork();
	if(pid<0)
	{
		printf("Fork failed");
	}
	if(pid==0)
	{
		//sleep(30);
		printf("\nIn Child Process\n");
		printf("\nChild Process ID: %d\n",getpid());
		printf("\nParent Process ID: %d\n",getppid());
		break;
	}
	else
	{
		printf("\nIn Parent Process\n");
		printf("\nChild Process ID: %d\n",pid);
		printf("\nParent Process ID: %d\n",getpid());
		int status=0;
		waitpid(pid,&status,0);
		if(WIFEXITED(status))
		{
			printf("\nExited Normally\n");
		}
	}
	}

	switch(i)
		{
			case 0:
				if(pid==0)
					execlp("firefox","firefox",NULL);
				break;
			case 1:
				if(pid==0)
					execlp("gedit","gedit",NULL);
				break;
			case 2:
				if(pid==0)
					execlp("firefox","firefox",NULL);
				break;
			case 3:
				if(pid==0)
					execlp("gedit","gedit",NULL);
				break;
			case 4:
				if(pid==0)
					execlp("firefox","firefox",NULL);
			default:
				printf("Invalid!\n");
				break;
		}
}

```

4. Create 5 processes from a common parent and ensure that the parent
terminates after cleaning all the terminated children using waitpid().
The waitpid() must be called after all the children are created
and the parent has completed its work real work,if any; in addition, you must
compile 5 different program files to in children processes to generate their
respective object files ; the parent process must use waitpid() to collect the
termination status of children processes – based on the exit code information
generated by children processes, link all the object files to
generate the final, linked program/application. In addition, the generated
binary executable must be loaded in a new process, if the linking is
successful
```
#include<stdio.h>
#include<unistd.h>
#include <sys/types.h>
#include <sys/wait.h>
int main()
{
	pid_t pid;
	int i;

	for(i=0;i<5;i++)
	{
	pid=fork();
	if(pid<0)
	{
		printf("Fork failed");
	}
	if(pid==0)
	{
		//sleep(30);
		printf("\nIn Child Process\n");
		printf("\nChild Process ID: %d\n",getpid());
		printf("\nParent Process ID: %d\n",getppid());
		break;
	}
	else
	{
		printf("\nIn Parent Process\n");
		printf("\nChild Process ID: %d\n",pid);
		printf("\nParent Process ID: %d\n",getpid());
		int status=0;
		waitpid(pid,&status,0);
		if(WIFEXITED(status))
		{
			printf("\nExited Normally\n");
		}
	execlp("/home/dac/Vriti/Calc","Calc",NULL);
	}
	}

	switch(i)
		{
			case 0:
				if(pid==0)
					execlp("gcc","gcc","-c","Add.c","-o","add",NULL);
				break;
			case 1:
				if(pid==0)
					execlp("gcc","gcc","-c","Sub.c","-o","sub",NULL);
				break;
			case 2:
				if(pid==0)
					execlp("gcc","gcc","-c","Multi.c","-o","multi",NULL);
				break;
			case 3:
				if(pid==0)
					execlp("gcc","gcc","-c","Divide.c","-o","divide",NULL);
				break;
			case 4:
				if(pid==0)
					execlp("gcc","gcc","add","sub","multi","divide","Main.c","-o","Calc",NULL);
			default:
				printf("Invalid!\n");
				break;
		}
}

```
